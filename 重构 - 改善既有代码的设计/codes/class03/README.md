# 3 代码的坏味道
>  味道，形容重构的时机
## 3.1 神秘命名(Mysterious Name)
命名是编程最难的两件事之一。整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。
## 3.2 重复代码(Duplicated Code)
最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。一旦有重复代码存在，我们需要加倍仔细留意其间微细的差异，把相似部分放在一起以便加以提炼。
## 3.3 过长函数(Long Function)
实践证明，活得最长、最好的程序，其中的函数都比较短。函数越长，越难理解。
## 3.4 过长参数列表(Long Parameter List)
使用类可以有效地缩短参数列表。
## 3.5 全局数据(Global Dat)
全局数据的问题就在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码作出了修改。最常见的全局数据时全局变量，但类变量和单例也有这样的问题。<br>
首要的防御手段就是封装变量。
## 3.6 可变数据(Mutable Data)
消除这种坏味道的办法：使用以查询取代派生变量。随着变量作用域的扩展，可以用函数组合成类或者函数组合成变换来限制需要对变量进行修改的代码量。  
## 3.7 发散式变化(Divergent Change)
如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当然，往往只有在加入新数据库或新金融工具后，你才能发现这个坏味道。
## 3.8 霰弹式修改(Shotgun Surgery)
霰弹式修改类似于发散式修改，但又恰恰相反。如果每遇到某种变化，你都必须再许多不同的类内作出许多小修改，你所面临的坏味道就是霰弹式修改。  
面对霰弹式修改，一个常用的策略就是使用与内联相关的重构————如内联函数或者内联类。
## 3.9 依恋情结(Feature Envy)
所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。  
但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。
## 3.10 数据泥团(Data Clumps)
我们常常可以在很多地方看到相同的三四项数据，这就是数据泥团的坏味道。常用的策略是提倡新建一个类，而不是简单的记录结构。  
有用的类被创建，大量的重复被消除，后续开发得以加速。
## 3.11 基本类型偏执(Primitive Obsession)
字符串是这种坏味道的最佳培养皿。  
可以运用以对象取代基本类型将原本单独存在的数据值替换为对象，从而走出传统的洞窟。  
如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码加上以多态取代条件表达式的组合将它替换掉。  
如果有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类和引入参数对象来代理。
## 3.12 重复的switch(Repeated Switches)
任何switch语句都应该用以多态取代条件表达式消除掉这种坏味道。
## 3.13 循环语句(Loops)
我们可以用以管道取代循环来让这些老古董退休。管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。
## 3.14 冗赘的元素(Lazy Element)

## 3.15 夸夸其谈通用性(Speculative Generality)
企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。
## 3.16 临时字段(Temporary Field)

## 3.17 过长的消息链(Message Chains)

## 3.18 中间人(Middle Man)

## 3.19 内幕交易(Insider Trading)
软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。
## 3.20 过大的类(Large Class)
如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复的代码就接踵而至了。  
有时候类并非在所有时刻都使用所有字段。若果真如此，你或许可以进行多次提炼。 
最简单的解决方案就是把多余的东西消弭于类内部。
## 3.21 异曲同工的类(Alternative Classes with Different Interfaces)
使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。
## 3.22 纯数据类(Data Class)
所谓纯数据是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。 
我们应该在别人注意到它们之前，立刻运用封装记录将它们封装起来。
## 3.23 被拒绝的遗赠(Refused Bequest)

## 3.24 注释(Comments)
当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。